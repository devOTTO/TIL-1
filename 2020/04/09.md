# [TIL] 2020-04-09

## 📔 리얼월드 HTTP 7장: HTTP/2
* 스트림을 사용해 바이너리 데이터를 다중 송수신
* 스트림 내 우선 순위 설정과 서버 사이드에서 데이터 통신을 하는 서버 사이드 푸시 구현
* 헤더가 압축되게 함

### 스트림을 이용한 통신고속화
요청마다 TCP 연결을 생성하지 않고, 하나의 TCP 연결에서 스트림이라는 단위로 병렬화

* HTTP2는 텍스트 기반 프로토콜에서 바이너리 기반 프로토콜로 변화함
* **기존** : 하나의 요청이 TCP 소켓을 독점했기 때문에, 하나의 서버에 대해 2-6개의 TCP 접속으로 병렬화
* **개선** : 하나의 TCP 접속 안에 **스트림**이라는 가상의 TCP 소켓을 만들어서 통신
* **스트림** : 프레임에 따른 플래그로 간단히 만들고 닫을 수 있는 규칙으로 되어있으며, 일반 TCP 소켓과 같은 핸드쉐이크가 필요하지 않음
	* ID, TCP 통신 용량이 허락하는 한, 손 쉽게 몇 만번의 접속도 병렬화 가능
	* ID 값은 30비트(전체 31비트 중 송수신 방향 결정 1비트는 제외), 약 10억회 병렬화 가능
* 스트림은 TCP의 `CLOSED` 상태로 대기하는 것이 아니라, `LISTEN`과 유사한 `IDLE` 상태로 대기하다가 헤더를 받으면 즉시 통신 가능한 `OPEN` 상태가 되기 때문에, 통신에 필요한 단계가 1단계 줄어듬
* `Stream Identifier` : 스트림 식별자로, 같은 값이만 같은 스트림 관련 프레임으로 인식하고 수신 시 그룹화 함
	* `0`은 예약되어 있어서, 사용하면 오류가 발생
	* 홀수는 클라이언트 to 서버, 짝수는 서버 to 클라이언트

### 📍 플로 컨트롤
스트림을 효율적으로 흐르게 하려고 이용되는 통신량 제어 처리
* **목적** : 통신 속도가 지나치게 차이 나는 기기의 조합으로 통신할 때, 빠른 쪽이 느린 쪽에 대량으로 패킷을 보내버려 처리할 수 없게 되는 사태를 방지하기 위함
* 통신하는 곳의 윈도우 크기 관리(받아들일 수 있는 빈 버퍼 크기)를 이용
* `SETTINGS` 프레임을 사용하면 초기 윈도우 크기, 최대 병렬 스트림 수, 최대 프레임 크기, 최대 헤더 리스트 크기와 같은 속도와 관련된 매개변수를 조정할 수 있음

#### ✅ 처리 과정
1. 송신 측에서 상대의 **최대 버퍼 크기만큼 데이터를 전송**
2. 수신 측에서 전송된 패킷을 처리하고 버퍼에 여유가 생기면, `WINDOW_UPDATE` 프레임을 이용해 새로 생긴 **여유 버퍼 크기를 송신 측에 반환**
3. 송신 측에서 통지를 받으면 새로 생긴 **여유 버퍼를 채울 만큼** 이어지는 데이터를 전송

### 📍 서버 푸시
우선순위가 높은 콘텐츠를 클라이언트가 요구하기 전에 전송할 수 있음
* 웹소켓과 같은 양방향 통신을 실현하는 기술과 다름
* CSS, 자바스크립트, 이미지 등 웹 페이지를 구성하는 파일을 다운로드 하는 용도로 사용
* 푸시된 컨텐츠는 캐시에 저장되고, 클라이언트는 해당 자원을 서버에 요청하기 전까지 푸시된 사실을 모르지만 요청하면 캐시에 저장된 데이터를 가져오기 때문에 즉시 다운로드 가능한 것처럼 보임
* 채팅, 구글 스프레드시트로 공동 편집 작업을 할 때 다른 사람이 입력한 주석을 서버가 배포하는 용도로는 사용할 수 없음

![image](https://user-images.githubusercontent.com/42922453/78874895-12562d80-7a88-11ea-9272-fe219ef6f85e.png)

> **Ref** : [Progressive Web App - HTTP2 서버 푸시(Server Push) | Programming is an Art](https://sunjoong85.github.io/pwa,/http2/2018/04/16/Pogressive-Web-App-HTTP2%EC%99%80-Server-Push.html) 

## 📔 ECMAScript 2020 정리
> **Ref** : https://ui.toast.com/weekly-pick/ko_20200409/?fbclid=IwAR2YWdr8_lOegZflaJSdAfG9nuTApDd3wNvRLmvA-KmNXNQhoNPzDUDqByo

### 📍 String.prototype.matchAll
기존의 match()는 정확히 일치하는 '결과만을 반환'했지만, matchAll()은 정규 표현식 그룹에 대한 더 세부적인 정보를 반환한다.

### 📍 `import()`
동적 가져오기(Dynamic import)를 통해 필요에 따라 모듈을 가져올 수 있다. 프로미스를 반환하므로 프로미스 체인이나 async/await로 import 완료에 대한 비동기 처리를 할 수 있다.

### 📍 `BigInt`: 임의 정밀도 정수
Number.MAX_SAFE_INTEGER를 제한 없이 사용할 수 있다. BigInt() 함수를 사용하거나, 숫자 뒤에 n을 붙여서 bigint 타입으로 만들 수 있다.

### 📍 `Promise.allSettled`
`Promise.all()`과 `Promise.race()`에 이어 새롭게 추가된 `Promise.allSettled()`는 모든 프로미스가 결과(이행/거절)에 관계없이 **완료되고 난 후 처리**를 위해 사용된다.

* `Promise.all()` : 모두 이행되어야 하며, 하나라도 거부하면 자신도 최초 거절 프로미스의 이유를 따라 거절함
* `Promise.race()` : 가장 먼저 완료된 것의 결과에 따라 이행/거절함

### 📍 `globalThis`
런타임에 맞는 적절한 전역 객체를 가져오는 방법
> 자바스크립트가 실행되는 런타임(브라우저, node, Javascript Core 등)에 맞는 전역 객체의 이름이 다 다르기 때문에, 전역객체 접근이 어렵다는 것이 추가된 배경 (strict mode에서는 this를 사용할 수 없는 문제 등)   

### 📍 for-in 메커니즘
자세히 설명되지 않았던 for-in 메커니즘의 규칙이 확정됨
> https://github.com/tc39/proposal-for-in-order 여기에서..  

### 📍 optional chaining
객체 프로퍼티에 접근하기 위한 `&&` 체인은 오류가 나기 쉽고, 가독성도 구리다. 
> Typescript에서는 3.7버전에 이미 구현되어 있다.  

`&&`로 연결할 필요 없이 `?.` 으로 다음 속성을 찾으면 됨
```js
const title = data?.article?.title
```

### 📍  null 병합 연산자
`||` 연산자와 반대로, null 병합 연산자 `??` 은 좌변 값이 `null` 이거나 `undefined` 일 때만 평가한다.
> || 은 각 자료형에서 false로 취급 되는 값도 다 우변 값을 취했다.  

```js
“” || “default value"
// default value

“” ?? “default value”
// “”
```

### 📍 `import.meta`
현재 실행중인 모듈에 호스트에 관한 메타 데이터 객체를 추가
> 아까 globalThis랑 약간 관계가 있어 보이는데, 모듈이 호스트 환경에 대한 정보를 알면 더 적절하게 구현할 수 있다? 이런 의도로 만들어진 것 같은데 제대로 이해는 못함. example 부분을 보니까 document의 정보를 import.meta로 가져와서 요청 등에 활용하는 예시가 있음  

### 📍 `export * as ns from "mod”`
다른 모듈의 것을 가져와서 해당 모듈에서 다른 이름으로 export 할 수 있다.
> 만약 mod2라는 파일에서 저 코드를 만들었다면 다른 곳에서 `import { ns } from "mod2”` 이런 식으로 쓸 수 있는 듯. 합치기 위한 좋은 방법인 것 같다.  
