# [TIL] 2020-04-11

## 🌏 스프링 프레임워크 입문 강의
### 📍 IoC(Inversion of Control) 컨테이너
> `ApplicationContext`라는 IoC 컨테이너는 자동으로 생성되어 (스스로) 빈으로 등록된다. 역할은 다른 빈을 관리하고, 의존성(내부에서 필요한 다른 객체/빈)이 있는 경우 필요한 객체를 생성자로 전달하는 것이다.  

- `ApplicationContext` (BeanFactory)
- 빈(bean)을 만들어주고, 엮어주고, 제공해준다.
	- 빈은 IoC 컨테이너 내부에서 해당 객체를 만들고 객체들 사이의 의존성을 엮어준다.
	- 필요한 의존성을 만들어서 생성자로 전달해준다.
- 아이러니하게도 직접 볼 일도 잘 없고, 직접 쓸 일도 많지 않다.
	- IoC 컨테이너 자체가 빈으로 등록되어 있어서, 보고 싶으면 `@Autowired`로 주입해서 볼 수 있다.
- IntelliJ에서 옆(라인넘버)에 콩이 있으면 빈이다.
	- `@Controller`, `@Component`, `@Service` 어노테이션이 붙어있으면 컴포넌트 스캔으로 빈으로 등록됨

### 📍 빈(Bean)
* 스프링 IoC 컨테이너가 관리하는 객체
* **등록하는 방법** : Component Scanning, XML이나 자바 설정 파일에 등록
	* `@SpringBootApplication`은 `@ComponentScan` 애노테이션을 가진다.
	* `@Bean` 애노테이션을 붙이면 직접 등록할 수 있음
		* `@Bean` 애노테이션을 메서드에 붙일 경우 `@Configuration` 애노테이션이 붙은 클래스 아래여야 한다.
		* ✅ 메서드에 빈을 등록하는 것은 무슨 경우?
* Component Scanning : 모든 패키지에 `@Component` 애노테이션이 붙은 클래스를 빈으로 등록함.
	* 아래 세 개의 애노테이션은 `@Component` 애노테이션을 가진다.
	* `@Repository`
	* `@Service`
	* `@Controller`
* 애노테이션 자체에는 기능이 없다. 주석과도 같음. 애노테이션을 마커로 사용해서 처리하는 프로세서가 있는 것.
* 꺼내 쓰는 방법 : `@Autowired`, `@Inject`, `ApplicationContext.getBean()`
* ⚠️ IoC 컨테이너는 빈의 의존성만 관리해주고, 빈이 아닌 클래스의 의존성은 관리해주지 않는다.

### 📍 의존성 주입(Dependency Injection)
* 필요한 의존성을 어떻게 받아올 것인가(`@Autowired`와 `@Inject`를 어디에 붙일까?)
* 빈의 생성자가 **하나만 있고** 파라미터 타입이 빈으로 등록되어 있으면, `@Autowired` 애노테이션이 없어도 빈을 주입해준다.
	* 이런 방법으로 코드를 짜면, 코드에서 `@Autowired`가 점점 사라지고 코드가 점점 깔끔해질 것.
	* 이런 과정을 알고 있지 못할 경우, 코드가 혼란스러워 질 염려도 있다.
* 필드나 Setter에 `@Autowired`를 붙일 수 있음
* 반드시 필요한 의존성이라면 생성자를 추천하고, Setter를 가지고 있다면 Setter에 붙이고, 아니면 필드에 붙이는 것을 권장.
	* Setter가 있는 경우, Setter를 이용해서 의존성을 변경하려는 것이므로 Setter에 붙이는 것이 자연스러울 것
	* Setter가 없는데 굳이 Setter를 추가해서 `@Autowired`를 붙일 필요는 없음. 오히려 나중에 변경이 될것이라는 혼란을 (혹은 변경될 가능성을 주는 위험을) 추가할 수 있음.

### 📍 AOP(Aspect Oriented Programming) 소개
* **흩어진 코드를 한 곳으로 모으는** 코딩 기법
* 흩어진 코드를 모으기 위해서 프록시 패턴을 사용할 수 있음. 스프링 AOP는 프록시 패턴을 사용하고 있음
* 반복되는 흩어진 코드는 한 곳으로 모으고 각각의 클래스는 본인이 해야할 일에 집중할 수 있도록 함
