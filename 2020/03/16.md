# [TIL] 2020-03-16

🔑 : Keep-Alive, 파이프라이닝, TLS, 공개 키, 비밀 키, 인증

## 📔 리얼월드 HTTP - 4.1 통신 고속화
HTTP/1.1의 대표적인 기능은 TLS를 통한 안전한 통신 제공과 Keep-Alive, 파이프라이닝의 통신고속화

### 📍 Keep-Alive
HTTP의 아래층은 TCP/IP 통신을 효율화하는 구조
* **Keep-Alive 이전** : 하나의 요청마다 통신을 닫아야 함
* **Keep-Alive 사용** : 연속된 요청에는 접속을 다시 이용
* TCP/IP 통신의 접속까지의 대기 시간이 줄어들고, 통신 처리량이 많아져서 속도가 올라간 것처럼 느껴짐

#### ☑️ `Keep-Alive` 사용
```
Connection: Keep-Alive
```

* 위 헤더를 받아들인 서버가 `Keep-Alive`를 지원하면, 같은 헤더를 응답 헤더에 추가해서 반환
* HTTP/1.1에서는 이 동작이 기본
* TLS 통신을 이용할 경우 `Keep-Alive`가 특히 통신 시간 감소에 효율적
* **RTT(round-trip time)** : 패킷이 1회 왕복하는 시간
	* TCP/IP는 접속할 때 1.5회 왕복 통신 필요 (1.5RTT 시간 소요)
	* TLS는 서버/클라이언트 통신 시작 전 핸드셰이크(handshake)에서 2RTT의 시간 소요

#### ☑️ `Keep-Alive` 종료
```
Connection: Close
```
* 클라이언트나 헤더 한 쪽에서 위 헤더를 사용해 접속을 종료
* **다른 방법** : 타임아웃 될 때까지 기다리기
* 자바스크립트를 이용해서 동적으로 요청을 보낼 수 있기 때문에, HTML 정적 분석으로 클라이언트 통신의 완료를 탐지하기 어려움
* `Keep-Alive` 종료를 명시적으로 보내는 것보다는, **타임아웃으로 접속 종료를 기다리는 것이 일반적**
* 한 쪽이 TCP/IP 연결을 끊는 순간에 통신이 완료되므로, 클라이언트나 서버 중 `Keep-Alive` 지속시간이 짧은 쪽이 사용됨
	* 각 브라우저나 서버마다 시간이 다름
* 통신이 지속되는 동안 OS 자원을 소비하므로, 사용하지 않으면 빨리 끊는 것이 바람직

### 📍 파이프라이닝
최초의 요청이 완료되기 전에 다음 요청을 보내는 기술
* 다음 요청까지의 대기 시간을 없앰으로써, 네트워크 가동률을 높이고 성능을 향상함
* `Keep-Alive` 이용을 전제로 함
* 서버는 요청이 들어온 순서대로 응답을 반환함

> 구현되어있어도 꺼져있는 경우가 많고, 제대로 동작하지 않는 경우가 많음. 기본 활성화 된 브라우저는 오페라, iOS 5 이후의 사파리 정도 뿐. 성능이 거의 좋아지지 않는다는 보고도 있음.  

* **HOL(head-of-line) 블로킹 문제** : 요청 받은 순서대로 응답해야 하므로, 응답 생성에 시간이 걸리거나 크기가 큰 파일을 반환하는 처리가 있으면 다른 응답에 영향을 줌
* 파이프라이닝을 지원하지 않는 서버를 위해 초기에 확인을 위한 요청을 보내야 하기 때문에, 성능을 제대로 살리지 못했다는 문제도 있음
* **결론** : 좋은 점이 있지만, 다양한 문제때문에 그대로 사용되지는 않는다.

> 파이프라인은 여러 문제를 해결하고 HTTP/2에서 스트림이라는 새로운 구조로 재탄생 함 🎉  

## 📔 리얼월드 HTTP - 4.2 전송 계층 보안(TLS)
통신 경로를 암호화하는 기술
* **SSL(Secure Sockets Layer)** : 보안 소켓 계층
	* TLS는 SSL 3.0을 바탕으로 1996년에 표준화 시작되어 HTTP/1.1 이후 완성됨
* 기존 프로토콜에 통신 경로의 안전성을 추가해 새로운 프로토콜을 만들어낼 수 있는 범용적인 구조
* HTTPS 포트는 443번을 사용해 HTTP(80번)와 다른 서비스로 취급됨
* 메일 전송 프로토콜 SMTP(25번)의 TLS 버전인 SMTPS(465번) 등 기존 프로토콜 버전 업에도 사용
* TLS는 SSL이라 불리는 경우도 많지만, 실제 SSL은 여러 취약성이 알려져 있어, RFC에서도 권장하지 않음
* ✅ TLS는 통신 경로 밖의 정보는 숨겨주지 않으므로, 사용자 정보를 평문으로 저장하지 않고 해시화해서 보호하는 것은 TLS와 관계없이 꼭 필요

> 중간자가 통신을 감청하거나 통신 내용을 변경하거나 클라이언트로 속여 요청을 보낼 수 있지만, TLS는 이러한 상태에서 도청, 조작, 사칭이 불가한 통신을 제공함  

### 📍 해시 함수
입력 데이터를 규칙에 따라 집약해감으로써 **해시 값으로 불리는 짧은 데이터를 생성**함
* **해시** : ‘잘게 저민 조각‘ 이라는 뜻

#### ☑️ 해시 함수의 수학적 특성
* 같은 알고리즘과 같은 입력데이터라면 결과로 생성되는 값은 항상 같다.
* 해시 값은 알고리즘이 같으면 길이가 고정된다.
* **약한 충돌 내성** : 해시 값에서 원래 데이터를 유추하기 어렵다.
* **강한 충돌 내성** : 같은 해시 값을 생성하는 다른 두 개의 데이터를 찾기 어렵다.

> 다운로드 한 파일이 깨지지 않았는지 확인할 때도 사용됨. (체크섬, 핑거프린트로 불림)  

#### ☑️ 유명 해시 함수
MD5(128비트), SHA-1(160비트), SHA-2(SHA-224, SHA256, SHA-384 …) 등이 있음
> 2016년 MD5, SHA-1은 보안 용도로 비추천 (뚫렸음)  

```
$ md5 index.rst
MD5 (index.rst) = 0918298fa0d9109348ds0f …
```

### 📍 공통 키 암호, 공개 키 암호, 디지털 서명
* 암호화에서 중요한 것은 알고리즘 자체를 비밀로 하는 것이 아니라, **알고리즘이 알려져도 안전하게 통신**할 수 있는 것
* 물리적 세계에서 은닉화는 키를 숨기는 것이지만, **암호화는 키로 원본 데이터를 파괴**하는 것
* **일반적으로 사용하는 방식** : 암호화 알고리즘은 공개하고, 암호화에 사용하는 키를 따로 준비하는 방식
* TLS에서는 **공통 키 방식**과 **공개 키 방식** 두 종류가 있음

#### ☑️ 공통 키 방식(대칭 암호)
자물쇠를 잠글 때, 열 때 모두 같은 열쇠를 사용하는 방식
* 통신하는 사람끼리 번호(키)를 공유해야 함
* 키로 원본 데이터를 파괴하고, 받은 쪽에서는 가지고 있던 키로 데이터를 복원해서 읽음
* TLS에서 일반 통신의 암호화에 사용함

#### ☑️ 공개 키 방식(비대칭 암호)
* 공개 키(자물쇠)로 암호화하고, 비밀 키(열쇠)로 해독함
* 암호화 된 데이터로 원본을 복원할 수는 있어도 자물쇠인 비밀 키를 추출할 수 없음
* **디지털 서명** : 비밀 키로 암호화 한 데이터를 보내면, 받은 사람이 공개 키로 데이터를 해독하고, 해독이 되면 해당 사람이 보낸 것이 확인 되는 원리

> 실제 디지털 서명은 본문 자체를 암호화 하는 것이 아니라, 먼저 해시화하고 그 결과를 암호화 함  

암호화는 완벽하지 않고, 현실적인 시간 내에서 해석이 가능한 경우 보안에 취약한 것으로 간주됨

### 📍 키 교환
클라이언트와 서버 사이에 키를 교환하는 것
* **간단한 방법** : 공통 키를 생성한 다음, 서버 인증서의 공개 키로 암호화해서 전송
* **키 교환 전용 알고리즘** : 여러 가지 중 DH(디피-헬먼) 알고리즘이 있음
	* 키 자체를 교환하는 것이 아니라, 각각 키 재료를 만들어 서로 교환하고 각자 계산해서 같은 키 얻음
* **ECDHE(타원곡선 디피-헬먼) 알고리즘** : 더 적은 비트 수를 사용해서 훨씬 강한 강도를 가짐

> 공통 키의 안전한 교환을 위해서 **경로에서 관측하는 것만으로 키를 찾아내기 어려운 키 교환 알고리즘**을 이용하는 것. 이 방법은 중간에 내용을 변경하는 공격에 약하므로, ✅ 인증서 인증을 함께 사용해서 조작 위험성을 줄임.  

### 📍 공통 키, 공개 키 방식 구분해서 사용하는 이유
공개 키 방식은 안전성이 높지만, 암호화/복호화에 필요한 연산량이 공통 키 방식보다 많아서 TLS는 두 가지 방식을 혼합해서 사용하고 있음

#### ☑️ TLS의 2단계 방식
1. 통신마다 한 번만 사용되는 공통 키를 만들고, 공개 키를 사용해 통신 상대에게 키를 전송함
2. 이후 공통 키로 고속 암호화

### 📍 TLS 통신 절차
1. 핸드셰이크 프로토콜로 통신을 확립하는 단계
2. 레코드 프로토콜로 불리는 통신 단계
3. `SessionTicket` 구조를 이용한 재접속 시 고속 핸드셰이크 단계

#### ☑️ 서버의 신뢰성 확인
* 브라우저는 서버에서 서버의 SSL 서버 인증서를 가져옴
	* **인증서 정보** : 사이트 주체(이름과 도메인), **발행자 서명**(인증 기관, CA), 소유자 서버 공개 키, 유효 기한 등
* 발행자의 인증서를 취득해서 서명을 검증 (상위 발행자 인증서도 차례로 검증)
* 발행자와 주체자가 동일한 인증서(루트 인증기관)까지 인증해서 서버가 승인된 것을 확인
* **자가 서명 인증서** : 신뢰가 확인되지 않은 발행자와 주체가 같은 인증서
	* OpenSSL 등의 도구로 손쉽게 만들 수 있음
	* 직접 만든 인증서를 OS에 등록해서 개인용 서비스 인증에 사용하거나 사내 전용 서버 확인에 사용 가능
* 서명 작성에 SHA-1 알고리즘을 이용한 인증서는 2016년부터 발행이 금지되고, 2017년부터 사용이 금지됨

> ✅ 인증서의 안전성은 공개 키 기반으로 발행자가 보증함  

#### ☑️ 키 교환과 통신 시작
키 교환은 공개 키 암호 사용 방식과 키 교환 전용 알고리즘 사용 방식이 있음
* **공개 키 암호 방식** : 통신용 공통 키를 서버 인증서에 첨부된 공개 키로 암호화해서 서버로 전달
* **키 교환 알고리즘 방식** : 키를 생성할 시드를 양측에서 하나씩 만들고, 서로 교환해서 계산한 결과가 공통 키
	* ✅ 순방향 비밀성(forward secrecy)이 우수함
	* 동적으로 계산되고 파일로 저장되지 않기 때문에 키가 유출될 일이 없음

#### ☑️  통신
통신을 할 때도 기밀성과 무결성 위해 암호화가 필요하며, **공통 키 암호 방식 알고리즘**을 사용함
* **TLS 1.2 이전** : 통신 내용 해시 값 계산 후, 공통 키 암호로 암호화 (전송 내용의 바이트 열에서 생성한 해시 값을 전송 데이터 끝에 붙여 조작을 탐지)
* **TLS 1.3 이후** : 위 기법에 대한 공격이 발견되어 `AES+GCM`, `AES+CCM`, `ChaCha20-Poly1305` 등의 인증 암호로 제한될 예정
	* (예) `AES+GCM` : 일반 공통 키와 별개로 12바이트의 키가 필요하며, 8바이트는 랜덤하게 만들어서 부여하고, 4바이트는 핸드셰이크 때 교환한 난수를 재료로 해시 함수를 이용해서 생성

#### ☑️  통신의 고속화
지금까지의 과정은 신규 접속의 흐름이고, 일반 접속에서는 
* TCP/IP 단계 1.5RTT
* TLS 핸드셰이크 2RTT
* HTTP 요청 1RTT
로, 합계가 4RTT가 소요됨. (TLS 사용하지 않으면 2RTT)

> TCP/IP 통신 마지막의 0.5RTT와 TLS 최초 통신이 함께 이루어지기 때문에  

* 통신에서 전기 신호가 도달하고 응답 오기까지 시간은 매우 긴 시간이므로, 왕복 시간을 줄여야 함
* TLS, HTTP에서는 `Keep-Alive`와 세션 재개 기능을 활용함
* `Keep-Alive` : 세션이 지속되므로, 최초 요청 이후 통신은 RTT가 1
* **세션 재개 기능** : 최초의 핸드셰이크에서 전에 사용하던 세션 ID를 보내면 이후 키 교환이 생략됨
	* = 1RTT로 세션이 재개됨
	* **TLS 1.3** : 사전에 키를 공유해 둠으로써 0RTT로 최초 요청부터 정보 전송 가능

### 📍 암호화 스위트
키 교환, 메시지 암호화, 서명 등에서 사용하는 **알고리즘 조합(=암호화 스위트)**을 리스트화해 관리하고 서버/클라이언트에서 공통으로 사용할 수 있는 것을 선택하는 시스템을 만들어, 새로운 알고리즘을 조금씩 도입하거나 낡은 알고리즘을 비추천하는 작업

### 📍 프로토콜 선택
애플리케이션 계층 프로토콜을 선택하는 확장 기능
#### ☑️ ALPN(Application-Layer Protocol Negotiation)
* 최초 핸드셰이크 시 클라이언트가(`ClientHello`) 서버에 ‘클라이언트가 이용 가능한 프로토콜 목록’을 전달
* 서버는 응답(`ServerHello`)으로 키 교환하고, 인증서와 함께 프로토콜 전달
* 선택 가능한 목록은 IANA에서 관리 (주로 HTTP 계열, WebRTC 계열 프로토콜)

- - - -
## 👻 Today..
암호화랑 관련된 부분을 공부했더니 머리가 아프긴 하다. 그래도 책에서 말했던 것처럼 깊게 들어가기보다는 전반적인 과정을 짚어줘서 확실히 도움이 많이 되고 용어나 전체 과정을 이해할 수 있는 부분이 좋았던 것 같다. 수준에 잘 맞는 책을 고른 것 같아서 다행. 
