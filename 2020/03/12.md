# [TIL] 2020-03-12
🔑 : 프록시, 캐시

## ⚙️ 개발 환경 설정
어제 노트북을 초기화해서 개발환경을 새로 세팅하는 중
* `zsh` : shell을 보다 더 편리하게 사용할 수 있도록 여러 기능을 제공
* `oh-my-zsh` : zsh 설정을 관리하기 위한 프레임워크, 여러 플러그인 사용 가능
* **git 설치** : Xcode 설치되어 있을 때, git 커맨드 최초 실행하면 설치할지 물어보는 메세지가 뜬다.

## 📔 리얼월드 HTTP - 2.7 프록시
* HTTP 등의 통신을 중계, 각종 부가 기능을 구현
* 외부 공격으로부터 네트워크를 보호하는 방화벽 역할
* 저속 통신 회선용으로 데이터를 압축해 속도를 높이는 필터, 컨텐츠 필터링에 사용
* 프록시 서버가 악용되지 않도록 인증을 이용해 보호하는 경우, `Proxy-Authenticate` 헤더에 인증 방식에 맞는 값을 추가함
* `X-Forwarded-For` : 중계 프록시의 경우, 중간의 호스트 IP 주소를 이 헤더에 기록
	* 기존에 사실상의 표준으로 사용되다, 2014년 RFC 7239로 표준화 됨
	* 예시) X-Forwarded-For : client, proxy1, proxy2

```
$ curl --http1.0 -x http://localhost:18888 -U user:pass http://example.com/helloworld
```
* `-U/--proxy-user` : 프록시 인증용 유저 정보🔑, 아이디:패스워드
* `—proxy-basic`, `—proxy-digest` : 프록시 인증 방식 변경

### 📍 프록시와 게이트웨이
* **프록시** : 통신 내용을 이해하고, 필요에 따라 컨텐츠를 수정하거나 서버 대신 응답
* **게이트웨이** : 통신 내용을 그대로 전송하고, 클라이언트는 중간에 게이트웨이의 존재를 몰라야 함

## 📔 리얼월드 HTTP - 2.8 캐시
컨텐츠가 변경되지 않았을 때, 로컬에 저장된 파일을 재사용함으로써 다운로드 횟수를 줄이고 성능을 높이는 방법

### 📍 갱신 일자에 따른 캐시
`If-Modified-Since`에 서버에서 반환된 일시를 전달하면, 이 값과 서버의 콘텐츠 일시를 비교
* **변경되었을 경우** : 컨텐츠를 바디에 전달
* **아닐 경우** :  `304 Not Modified`를 반환

### 📍 Expires
(갱신 일시 방법은 캐시 유효성 검사를 위해 통신이 발생하기 때문에) 통신 없이 **지정한 기한 내일 경우 이용 가능**한 것으로 판단
* 3초 후 컨텐츠 유효 기간이 끝난다고 설정해도, 리로드 하지 않고 접속을 할지 말지 판단할 때만 사용
* 뒤로 가기 등으로 방문 이력을 조작하는 경우, 기한 지난 컨텐츠 그대로 사용될 수 있음
* 서버에 변경사항을 묻지 않으므로, SNS 톱페이지 등에 사용할 때 주의해야 함
* 스타일시트 등 자주 갱신되지 않는 정적 컨텐츠에 사용하는 것이 바람직함

###  📍  `Pragma: no-cache`
요청한 컨텐츠가 이미 저장되어 있어도, 원래 서버(오리진 서버)에서 가져오도록 지시
*  `Cache-Control`로 통합되었지만, 1.1 이후에도 하위 호환성 유지를 위해 남아있음
* REST는 ‘클라이언트가 컨텐츠의 의미 등을 사전 지식으로 갖지 않는 것’을 목표로 하기 때문에, 이런 방식의 사용을 권장하지는 않음
* 프록시가 중간에서 하나라도 `no-cache`를 무시하면 기대한 대로 동작하지 않기 때문에, 보증할 수 없음
* HTTP2 이후 보안 접속 비율이 증가했기 때문에, 프록시가 통신 내용을 감지하지 못하고 중계만 하므로 프록시 캐시를 외부에서 적극 관리하는 의미가 없음

### 📍 ETag 추가
여러 가지 정보를 조합해서 유효성을 판단하는 값 지정하는 방법

1. 최초 요청 시, 서버는 응답에 `ETag` 헤더를 부여
2. 이후 다운로드 시 클라이언트는 `If-None-Match` 헤더에 (1)에서 받은 `ETag` 값을 추가해서 요청
3. 서버에서 보내려는 파일의 `ETag`와 비교해 같으면 `304 Not Modified`로 응답

`ETag` 값은 서버가 자유롭게 결정해서 반환할 수 있음
* 생성일시 외에도 갱신 정보를 고려한 해시 값을 서버가 생성할 수 있음
* **일부 웹서버(nginx, h2o)** : `갱신일시-파일크기` 형식 (갱신 일시의 유닉스 시간-파일 크기의 바이트를 각각 16진수로 연결)
* **예전 아파치** : 갱신 일시, 크기 이외에 inode 번호(디스크상의 컨텐츠를 나타내는 인덱스 값, 동일 드라이브 내에서 고유) 사용
	* 서버를 여러 대 병렬한 경우, 같은 컨텐츠인데 아이디가 달라 `ETag`가 달라져서 캐시 낭비 발생
	* 그 외에도 잠재적 공격 기회를 허용하는 문제, 자식 프로세스 ID가 멀티파트 MIME 바운더리에서 유출될 수 있는 문제(?) 수정됨

### 📍 Cache-Control (1) - 서버의 응답에서 사용하는 설정값
더 유연한 캐시 제어를 지시할 수 있고, `Expires` 보다 우선해서 처리됨

> `Cache-Control`은 리로드를 억제하는 시스템이며, 개인 정보 보호 목적으로 사용할 수 없음  

* `public` : 같은 컴퓨터를 사용하는 복수의 사용자간 캐시 재사용을 허가
* `private` : 같은 컴퓨터를 사용하는 다른 사용자 간 캐시를 재사용하지 않음
	*  같은 URL에서 사용자마다 다른 컨텐츠가 돌아오는 경우, 이상한 결과가 되지 않도록 지시
	* 보안 접속이 아니면 통신 경로에서 내용이 보이기 때문에, 보안 목적으로 착각하면 안됨
* `max-age=n` : 캐시 신선도를 초단위로 설정(86400 : 하루동안 캐시가 유효)
* `s-maxage=n` : `max-age`와 같으나, 공유 캐시에 대한 설정값
* `no-cache` : 캐시가 유효한지 매번 문의 (`max-age=0`과 거의 같음)
* `no-store` : 캐시하지 않음
	* 캐시 서버가 저장하지 않을 뿐, 캐시 서버가 통신 내용 감시를 억제하는 기능은 없음
* `no-transform` : 프록시가 컨텐츠 변경하는 것을 제어
* `must-revalidate` : `no-cache`와 비슷하지만, 프록시 서버에 보내는 지시가 됨
	* 프록시가 서버에 문의했을 때 서버의 응답이 없으면, 프록시가 클라이언트에 `504 Gateway Timeout`을 반환하도록 함
* `proxy-revalidate` : `must-revalidate`와 같지만, 공유 캐시에만 요청

> `no-cache`는 `Pragma: no-cache`와 똑같이 캐시하지 않는 것은 아니고, 시간을 보고 서버에 접속하지 않은 채 컨텐츠를 재이용하는 것을 그만둠. 캐시하지 않는 것은 `no-store`  

* 콤마로 구분해서 복수 지정이 가능
* `public`, `private` 둘 중에서는 하나만 선택, 기본은 `private`
* `max-age`, `s-maxage`, `no-cache`, `no-store` 중 하나
* 모순된 설정의 우선순위에 대한 명세는 없음 (궁금하면 직접 실험해봅시다👨🏻‍🔬)

### 📍 Cache-Control (2) - 클라이언트의 요청에서 사용하는 설정값
* `no-cache` : `Pragma: no-cache`와 같음
* `no-store` : 응답의 `no-store`와 같고, 프록시 서버에 캐시를 삭제하도록 요청
* `max-age` : 프록시에서 저장된 캐시가 최초로 저장되고 나서, 지정 시간 이상 캐시는 사용하지 않도록 프록시에 요청
* `max-satle` : 캐시 유지 기간이 지났어도, 지정 시간 동안 저장된 캐시 재사용 하도록 프록시에 요청
	* 연장 시간은 생략할 수 있고, 그런 경우 영원히 유효하다는 의미
* `min-fresh` : 캐시 수명 남아 있을 때, 캐시 보내도 좋다고 프록시에 요청 (적어도 지정된 시간 만큼은 유효해야 함)
* `no-transform` : 프록시가 컨텐츠 변형하지 않도록 요청
* `only-if-cached` : 캐시된 경우에만 응답 반환하고, 캐시된 컨텐츠 없을 때는 `504 Gateway Timeout` 반환하도록 프록시에 요청
	* 처음을 제외하고 오리진 서버에 전혀 액세스하지 않음 _(대체 언제 쓰나)_

### 📍 Vary
같은 URL이라도, 클라이언트에 따라 반환 결과가 다름을 나타내는 헤더
* 스마트폰용 브라우저의 경우 모바일 페이지가 표시되는 경우
* 사용 언어에 따라 내용이 바뀌는 경우

```
Vary: User-Agent, Accept-Language
```
위와 같이 표시가 바뀌는 이유를 나열하며, 검색 엔진용 힌트로도 사용됨

> 브라우저 종류에 따라 컨텐츠가 바뀌는 것은, 모바일 버전이 다르게 보인다고 판단할 수 있는 재료가 되고, 언어별로 바르게 인덱스를 만드는 힌트가 됨  

* `User-Agent`로 모바일 판정 : 관례적인 것이지, 정규화 된 값은 아니고 바꿀 수도 있음
* **2017 구글 가이드라인** : 같은 컨텐츠를 모든 브라우저에 배포하고, 브라우저가 필요한 설정을 선택하도록 하는 반응형 웹 디자인을 권장 

## 🌏 웹 캐시의 종류
Ref : [더 빠른 웹을 위하여 - 웹 캐쉬 (WEB CACHE) :: 사이버이메지네이션 블로그](https://cyberx.tistory.com/9)

### 📍 브라우저 캐시
* 브라우저 또는 요청하는 클라이언트 애플리케이션에 의해 내부 디스크에 저장
* 캐시된 자원을 공유하지 않는 한, 개인에 한정된 Cache
* 브라우저의 뒤로가기 버튼이나 재방문 페이지에 효과적인 캐시

### 📍 프록시 캐시 (잘 이해 못함)
```
프록시 서버는 클라이언트가 자신을 통해서 다른 네트워크 서비스에 
간접적으로 접속할 수 있게 해주는 컴퓨터나 application을 가리키는데 
이 프록시 서버는 요청된 내용들을 cache를 이용하여 저장을 한다. 
cache 안에 있는 정보를 요구하는 요청에 대해서 
원격 서버에 접속하여 데이터를 가져올 필요가 없게 된다. 
그리고 외부와의 traffic을 줄여 bottle neck 을 방지한다.

- 출처 : https://pjh3749.tistory.com/190 [JayTech의 기술 블로그]
```

* 브라우저 캐시와 동일한 원리로 동작하며, 네트워크 상에서 동작
* 큰 회사나 IPS의 방화벽에 설치됨
* 한정된 수의 클라이언트를 위해 무한대의 웹 서버 컨텐츠를 캐시

### 📍 게이트웨이 캐시 (리버스 프록시)
* 서버 앞 단에 설치되어 요청에 대한 캐시 효율적 분배를 통해 가용성과 신뢰성 향상
* 암호화, 로드 밸런싱, 정적 컨텐츠, 압축 등을 수행
* 무한대의 클라이언트에게 한정된 수의 웹 서버 컨텐츠를 제공

- - - -
## 오늘의 Summary
프록시, 캐시에 대해서 공부했는데, 그동안 제대로 공부해보지 못하고 들어만 본 부분이어서 꼼꼼하게 공부하려고 노력했다. 노력은 했으나, 아직 확실하게 이해 못한 부분이 많은 듯. 특히 게이트웨이랑 프록시가 이해가 잘 안된다. 내일 조금 더 공부해보고 책은 2장의 리퍼러, 검색 엔진 부분을 마무리해야겠다.
